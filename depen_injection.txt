{
  "name": "agentic-test-writer",
  "displayName": "Agentic Test Writer",
  "description": "Generate Python tests using GitHub Copilot agentic workflows",
  "version": "1.0.0",
  "publisher": "jerry",
  "engines": {
    "vscode": "^1.85.0"
  },
  "capabilities": {
    "languageModels": true
  },
  "activationEvents": [
    "onCommand:agenticTestWriter.generateTests"
  ],
  "main": "extension.js",
  "contributes": {
    "commands": [
      {
        "command": "agenticTestWriter.generateTests",
        "title": "Agentic: Generate Python Tests"
      }
    ]
  },
  "dependencies": {}
}

-------------------------------------
const vscode = require("vscode");
const path = require("path");

async function activate(context) {
  let disposable = vscode.commands.registerCommand(
    "agenticTestWriter.generateTests",
    async function () {
      const editor = vscode.window.activeTextEditor;
      if (!editor) {
        vscode.window.showErrorMessage("Open a Python file first.");
        return;
      }

      const document = editor.document;
      const code = document.getText();
      const fileName = path.basename(document.fileName);

      // Select a Copilot chat model
      const models = await vscode.lm.selectChatModels({
        vendor: 'copilot'
      });

      if (!models || models.length === 0) {
        vscode.window.showErrorMessage("No Copilot models available.");
        return;
      }

      const model = models[0];

      const prompt = `
You are an AI agent that writes high-quality Python unit tests.

Output ONLY the complete Python code for pytest-style tests. Do not include any planning, explanation, workflow steps, markdown, or comments. Start directly with the imports.

Focus on:
- edge cases
- error handling
- correct assertions
- realistic inputs
- mock complex dependencies
- full coverage

Python file name: ${fileName}

Code:
${code}
`;

      const messages = [
        vscode.LanguageModelChatMessage.User(prompt)
      ];

      const token = new vscode.CancellationTokenSource().token;
      let response;
      try {
        response = await model.sendRequest(messages, {}, token);
      } catch (error) {
        vscode.window.showErrorMessage(`Failed to send request to Copilot: ${error.message}`);
        return;
      }

      if (!response || !response.stream) {
        vscode.window.showErrorMessage("Copilot did not return a valid response.");
        return;
      }

      let responseText = '';
      try {
        for await (const chunk of response.stream) {
          // Handle different chunk formats
          if (typeof chunk === 'string') {
            responseText += chunk;
          } else if (chunk && typeof chunk === 'object') {
            // Try common properties for content
            if (chunk.content) {
              responseText += chunk.content;
            } else if (chunk.text) {
              responseText += chunk.text;
            } else if (chunk.delta) {
              responseText += chunk.delta;
            } else if (chunk.value) {
              responseText += chunk.value;
            } else {
              // Fallback: try to stringify or log for debugging
              console.log('Unknown chunk format:', JSON.stringify(chunk, null, 2));
            //   responseText += JSON.stringify(chunk);
            }
          }
        }
      } catch (error) {
        vscode.window.showErrorMessage(`Failed to read Copilot response: ${error.message}`);
        return;
      }

      if (!responseText) {
        vscode.window.showErrorMessage("Copilot did not return any tests.");
        return;
      }

      const testFileName = `test_${fileName}`;
      const testUri = vscode.Uri.joinPath(
        vscode.workspace.workspaceFolders[0].uri,
        testFileName
      );

      await vscode.workspace.fs.writeFile(
        testUri,
        Buffer.from(responseText, "utf8")
      );

      vscode.window.showInformationMessage(
        `Generated tests â†’ ${testFileName}`
      );

      const doc = await vscode.workspace.openTextDocument(testUri);
      vscode.window.showTextDocument(doc);
    }
  );

  context.subscriptions.push(disposable);
}

function deactivate() {}

module.exports = {
  activate,
  deactivate,
};
